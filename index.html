<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teddy Bear Soft-Body Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #simulation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        #canvas {
            border: 2px solid #333;
            background: white;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .slider {
            width: 100px;
        }
        
        #performance-info {
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            display: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
</head>
<body>
    <div id="simulation-container">
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div id="controls">
            <div class="control-group">
                <button id="reset-btn">Reset Bear</button>
                <button id="pause-btn">Pause</button>
            </div>
            
            <div class="control-group">
                <label>Softness:</label>
                <input type="range" id="softness-slider" class="slider" min="0" max="100" value="70">
                <span id="softness-value">0.7</span>
            </div>
            
            <div class="control-group">
                <label>Gravity:</label>
                <input type="range" id="gravity-slider" class="slider" min="0" max="200" value="80">
                <span id="gravity-value">0.8</span>
            </div>
            
            <div class="control-group">
                <button id="debug-btn">Debug Mode</button>
            </div>
        </div>
        
        <div id="performance-info">
            FPS: <span id="fps">60</span> | Physics Time: <span id="physics-time">0</span>ms | Particles: <span id="particle-count">0</span>
        </div>
    </div>
    
    <div id="debug-info" class="debug-info">
        <div>Bear Position: <span id="bear-position">0, 0</span></div>
        <div>Active Constraints: <span id="constraint-count">0</span></div>
        <div>Memory Usage: <span id="memory-usage">0</span>MB</div>
        <div>Collision Pairs: <span id="collision-pairs">0</span></div>
    </div>

    <script>
        /**
         * Teddy Bear Soft-Body Physics Simulation
         * Implementation following SPARC methodology and TDD principles
         * Based on comprehensive specifications and architecture design
         */

        // ========================================
        // Core Configuration
        // ========================================
        
        const CONFIG = {
            canvas: {
                width: 800,
                height: 600,
                pixelRatio: window.devicePixelRatio || 1
            },
            
            physics: {
                gravity: { x: 0, y: 0.3, scale: 0.001 },
                airFriction: 0.02,
                constraintIterations: 8,
                positionIterations: 12,
                velocityIterations: 8,
                enableSleeping: true,
                sleepThreshold: 60
            },
            
            bear: {
                position: { x: 400, y: 150 },
                scale: 1.0,
                softness: 0.1, // Much firmer for stability
                density: 0.0005,
                // Single unified bear body shape
                dimensions: { width: 120, height: 180 },
                particleSize: 4,
                particleCount: { x: 24, y: 34 }, // Match CSV dimensions exactly
                shape: 'rounded' // Special rounded bear shape
            },
            
            rendering: {
                wireframes: true,
                background: 'transparent',
                showConstraints: true,
                showParticles: false,
                particleColors: {
                    head: '#333333',
                    torso: '#333333',
                    arm: '#333333',
                    leg: '#333333'
                },
                constraintStyle: {
                    strokeStyle: '#666666',
                    lineWidth: 1
                }
            },
            
            interaction: {
                enabled: true,
                dragStiffness: 0.1,
                maxForce: 0.005,
                grabRadius: 15
            },
            
            performance: {
                targetFPS: 60,
                adaptiveQuality: true,
                monitorInterval: 1000
            }
        };

        // ========================================
        // TeddyBear Simulation Core Class
        // ========================================
        
        class TeddyBearSimulation {
            constructor(canvas, config = CONFIG) {
                this.canvas = canvas;
                this.config = { ...config };
                this.state = 'UNINITIALIZED';
                
                // Core systems
                this.engine = null;
                this.render = null;
                this.runner = null;
                this.mouseConstraint = null;
                
                // Teddy bear components
                this.teddyBear = null;
                this.segments = new Map();
                this.joints = [];
                this.world = null;
                
                // Performance monitoring
                this.performanceMonitor = new PerformanceMonitor();
                this.lastUpdateTime = 0;
                this.frameCount = 0;
                
                // Event handlers
                this.eventHandlers = new Map();
                
                // Collision groups
                this.collisionGroups = {
                    BEAR: -1,
                    ENVIRONMENT: 0,
                    MOUSE: 1
                };
            }
            
            /**
             * Initialize the simulation
             */
            async initialize() {
                try {
                    this.setupPhysicsEngine();
                    this.setupRenderer();
                    this.createEnvironment();
                    this.createTeddyBear();
                    this.setupInteraction();
                    this.setupEventHandlers();
                    this.setupPerformanceMonitoring();
                    
                    this.state = 'INITIALIZED';
                    console.log('Teddy bear simulation initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize simulation:', error);
                    throw error;
                }
            }
            
            /**
             * Setup Matter.js physics engine
             */
            setupPhysicsEngine() {
                this.engine = Matter.Engine.create({
                    gravity: this.config.physics.gravity,
                    timing: {
                        timeScale: 1,
                        fixedDelta: 1000 / this.config.performance.targetFPS
                    },
                    velocityIterations: this.config.physics.velocityIterations,
                    positionIterations: this.config.physics.positionIterations,
                    constraintIterations: this.config.physics.constraintIterations,
                    enableSleeping: this.config.physics.enableSleeping
                });
                
                this.world = this.engine.world;
                
                // Configure world bounds for better performance
                this.engine.world.bounds = {
                    min: { x: -2000, y: -2000 },
                    max: { x: 2000, y: 2000 }
                };
            }
            
            /**
             * Setup Matter.js renderer
             */
            setupRenderer() {
                this.render = Matter.Render.create({
                    canvas: this.canvas,
                    engine: this.engine,
                    options: {
                        width: this.config.canvas.width,
                        height: this.config.canvas.height,
                        wireframes: this.config.rendering.wireframes,
                        background: this.config.rendering.background,
                        wireframeBackground: 'transparent',
                        showAngleIndicator: false,
                        showVelocity: false,
                        showIds: false,
                        showSeparations: false,
                        showCollisions: false,
                        showVertexNumbers: false,
                        showConvexHulls: false,
                        showBounds: false,
                        showDebug: false
                    }
                });
            }
            
            /**
             * Create environment (floor and walls)
             */
            createEnvironment() {
                const ground = Matter.Bodies.rectangle(
                    this.config.canvas.width / 2,
                    this.config.canvas.height - 30,
                    this.config.canvas.width,
                    60,
                    {
                        isStatic: true,
                        collisionFilter: {
                            group: this.collisionGroups.ENVIRONMENT,
                            category: 0x0002,
                            mask: 0xFFFF
                        },
                        render: {
                            fillStyle: 'transparent',
                            strokeStyle: '#333333',
                            lineWidth: 2
                        }
                    }
                );
                
                const leftWall = Matter.Bodies.rectangle(
                    -30,
                    this.config.canvas.height / 2,
                    60,
                    this.config.canvas.height,
                    {
                        isStatic: true,
                        collisionFilter: {
                            group: this.collisionGroups.ENVIRONMENT,
                            category: 0x0002,
                            mask: 0xFFFF
                        },
                        render: { visible: false }
                    }
                );
                
                const rightWall = Matter.Bodies.rectangle(
                    this.config.canvas.width + 30,
                    this.config.canvas.height / 2,
                    60,
                    this.config.canvas.height,
                    {
                        isStatic: true,
                        collisionFilter: {
                            group: this.collisionGroups.ENVIRONMENT,
                            category: 0x0002,
                            mask: 0xFFFF
                        },
                        render: { visible: false }
                    }
                );
                
                Matter.World.add(this.world, [ground, leftWall, rightWall]);
            }
            
            /**
             * Create the teddy bear with soft-body physics
             */
            createTeddyBear() {
                const bearConfig = this.config.bear;
                const bearPosition = bearConfig.position;
                
                // Create single unified bear body with rounded shape
                const particles = this.createRoundedBearParticles(bearPosition, bearConfig);
                const constraints = this.createBearConstraintNetwork(particles, bearConfig);
                
                // Add all particles and constraints to world
                Matter.World.add(this.world, particles);
                Matter.World.add(this.world, constraints);
                
                // Store bear reference
                this.teddyBear = {
                    particles: particles,
                    constraints: constraints,
                    position: bearPosition,
                    config: bearConfig
                };
                
                console.log(`Created unified teddy bear with ${particles.length} particles`);
            }
            
            /**
             * Create particles in a rounded teddy bear shape
             */
            createRoundedBearParticles(center, config) {
                const particles = [];
                const { particleCount, dimensions, particleSize } = config;
                const spacing = {
                    x: dimensions.width / (particleCount.x - 1),
                    y: dimensions.height / (particleCount.y - 1)
                };
                
                for (let row = 0; row < particleCount.y; row++) {
                    for (let col = 0; col < particleCount.x; col++) {
                        const x = center.x - dimensions.width / 2 + col * spacing.x;
                        const y = center.y - dimensions.height / 2 + row * spacing.y;
                        
                        // Check if this position should have a particle (bear shape)
                        if (this.isInsideBearShape(col, row, particleCount)) {
                            const particle = Matter.Bodies.circle(x, y, particleSize, {
                                density: config.density,
                                frictionAir: this.config.physics.airFriction,
                                inertia: Infinity, // Prevents particle drift
                                collisionFilter: {
                                    group: this.collisionGroups.BEAR,
                                    category: 0x0001,
                                    mask: 0x0002 | 0x0001 // Collide with environment and mouse
                                },
                                render: {
                                    fillStyle: 'transparent',
                                    strokeStyle: '#333333',
                                    lineWidth: 1,
                                    visible: this.config.rendering.showParticles
                                }
                            });
                            
                            // Store grid position for constraint creation
                            particle.gridRow = row;
                            particle.gridCol = col;
                            particles.push(particle);
                        }
                    }
                }
                
                return particles;
            }
            
            /**
             * Determine if a grid position should have a particle (teddy bear shape)
             * Based on EXACT bear.csv pattern data
             */
            isInsideBearShape(col, row, particleCount) {
                // EXACT pattern from bear.csv - each array contains column indices where 'x' appears
                const bearPattern = [
                    [7,8,9,13,14,15], // row 0 - ears
                    [6,7,8,9,10,11,12,13,14,15,16], // row 1
                    [6,7,8,9,10,11,12,13,14,15,16], // row 2
                    [6,7,8,9,10,11,12,13,14,15,16], // row 3
                    [7,8,9,10,11,12,13,14,15], // row 4
                    [7,8,9,10,11,12,13,14,15], // row 5
                    [7,8,9,10,11,12,13,14,15], // row 6
                    [8,9,10,11,12,13,14], // row 7 - 7 wide
                    [8,9,10,11,12,13,14], // row 8 - 7 wide
                    [9,10,11,12,13], // row 9 - neck: 5 wide
                    [7,8,9,10,11,12,13,14,15], // row 10
                    [5,6,7,8,9,10,11,12,13,14,15,16,17], // row 11
                    [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18], // row 12
                    [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19], // row 13
                    [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], // row 14
                    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21], // row 15
                    [0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22], // row 16 - eye gaps at 6,16
                    [0,1,2,3,4,7,8,9,10,11,12,13,14,15,18,19,20,21,22], // row 17 - eye gaps at 5,6,16,17
                    [0,1,2,3,7,8,9,10,11,12,13,14,15,19,20,21,22], // row 18 - eye gaps at 4,5,6,16,17,18
                    [1,2,7,8,9,10,11,12,13,14,15,20,21], // row 19
                    [7,8,9,10,11,12,13,14,15], // row 20
                    [7,8,9,10,11,12,13,14,15], // row 21
                    [7,8,9,10,11,12,13,14,15], // row 22
                    [7,8,9,10,11,12,13,14,15], // row 23
                    [7,8,9,10,12,13,14,15], // row 24 - leg gap at 11
                    [7,8,9,10,12,13,14,15], // row 25 - leg gap at 11
                    [7,8,9,10,12,13,14,15], // row 26 - leg gap at 11
                    [7,8,9,10,12,13,14,15], // row 27 - leg gap at 11
                    [7,8,9,10,12,13,14,15], // row 28 - leg gap at 11
                    [6,7,8,9,10,12,13,14,15,16], // row 29
                    [5,6,7,8,9,10,12,13,14,15,16,17], // row 30
                    [5,6,7,8,9,10,12,13,14,15,16,17], // row 31
                    [5,6,7,8,9,10,12,13,14,15,16,17], // row 32
                    [6,7,8,9,13,14,15,16] // row 33 - feet with gaps at 10,11,12
                ];

                // Direct mapping since we now match CSV dimensions exactly
                if (row >= 0 && row < bearPattern.length) {
                    return bearPattern[row].includes(col);
                }
                
                return false;
            }
            
            /**
             * Create constraint network for unified bear soft-body
             */
            createBearConstraintNetwork(particles, config) {
                const constraints = [];
                const stiffness = 1 - config.softness;
                
                // Create a mapping of grid positions to particles for easier lookup
                const particleMap = new Map();
                particles.forEach(particle => {
                    const key = `${particle.gridRow},${particle.gridCol}`;
                    particleMap.set(key, particle);
                });
                
                particles.forEach(particle => {
                    const row = particle.gridRow;
                    const col = particle.gridCol;
                    
                    // Horizontal constraints (connect to right neighbor)
                    const rightKey = `${row},${col + 1}`;
                    if (particleMap.has(rightKey)) {
                        const rightParticle = particleMap.get(rightKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: rightParticle,
                            stiffness: Math.max(0.8, stiffness * 0.9), // Much stronger for dense grid
                            damping: 0.05,
                            length: this.getDistance(particle.position, rightParticle.position),
                            render: {
                                visible: this.config.rendering.showConstraints,
                                strokeStyle: this.config.rendering.constraintStyle.strokeStyle,
                                lineWidth: this.config.rendering.constraintStyle.lineWidth
                            }
                        });
                        constraints.push(constraint);
                    }
                    
                    // Vertical constraints (connect to bottom neighbor)
                    const bottomKey = `${row + 1},${col}`;
                    if (particleMap.has(bottomKey)) {
                        const bottomParticle = particleMap.get(bottomKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: bottomParticle,
                            stiffness: Math.max(0.8, stiffness * 0.9), // Much stronger for dense grid
                            damping: 0.05,
                            length: this.getDistance(particle.position, bottomParticle.position),
                            render: {
                                visible: this.config.rendering.showConstraints,
                                strokeStyle: this.config.rendering.constraintStyle.strokeStyle,
                                lineWidth: this.config.rendering.constraintStyle.lineWidth
                            }
                        });
                        constraints.push(constraint);
                    }
                    
                    // Diagonal constraints for stability (lighter)
                    const diagonalKey = `${row + 1},${col + 1}`;
                    if (particleMap.has(diagonalKey)) {
                        const diagonalParticle = particleMap.get(diagonalKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: diagonalParticle,
                            stiffness: Math.max(0.6, stiffness * 0.7), // Stronger diagonal support
                            damping: 0.05,
                            length: this.getDistance(particle.position, diagonalParticle.position),
                            render: {
                                visible: this.config.rendering.showConstraints,
                                strokeStyle: this.config.rendering.constraintStyle.strokeStyle,
                                lineWidth: this.config.rendering.constraintStyle.lineWidth * 0.5
                            }
                        });
                        constraints.push(constraint);
                    }
                    
                    // Anti-diagonal constraints
                    const antiDiagonalKey = `${row + 1},${col - 1}`;
                    if (particleMap.has(antiDiagonalKey)) {
                        const antiDiagonalParticle = particleMap.get(antiDiagonalKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: antiDiagonalParticle,
                            stiffness: Math.max(0.6, stiffness * 0.7), // Stronger diagonal support
                            damping: 0.05,
                            length: this.getDistance(particle.position, antiDiagonalParticle.position),
                            render: {
                                visible: this.config.rendering.showConstraints,
                                strokeStyle: this.config.rendering.constraintStyle.strokeStyle,
                                lineWidth: this.config.rendering.constraintStyle.lineWidth * 0.5
                            }
                        });
                        constraints.push(constraint);
                    }
                });
                
                // Add shape-preserving constraints (connect particles 2-3 steps away)
                particles.forEach(particle => {
                    const row = particle.gridRow;
                    const col = particle.gridCol;
                    
                    // Long-range horizontal constraints (2 steps away)
                    const farRightKey = `${row},${col + 2}`;
                    if (particleMap.has(farRightKey)) {
                        const farRightParticle = particleMap.get(farRightKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: farRightParticle,
                            stiffness: 0.9, // Very strong shape preservation
                            damping: 0.02,
                            length: this.getDistance(particle.position, farRightParticle.position),
                            render: {
                                visible: false // Hide these structural constraints
                            }
                        });
                        constraints.push(constraint);
                    }
                    
                    // Long-range vertical constraints (2 steps away)
                    const farBottomKey = `${row + 2},${col}`;
                    if (particleMap.has(farBottomKey)) {
                        const farBottomParticle = particleMap.get(farBottomKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: farBottomParticle,
                            stiffness: 0.9, // Very strong shape preservation
                            damping: 0.02,
                            length: this.getDistance(particle.position, farBottomParticle.position),
                            render: {
                                visible: false // Hide these structural constraints
                            }
                        });
                        constraints.push(constraint);
                    }
                    
                    // Long-range diagonal constraints for overall stability
                    const farDiagonalKey = `${row + 2},${col + 2}`;
                    if (particleMap.has(farDiagonalKey)) {
                        const farDiagonalParticle = particleMap.get(farDiagonalKey);
                        const constraint = Matter.Constraint.create({
                            bodyA: particle,
                            bodyB: farDiagonalParticle,
                            stiffness: 0.8, // Strong shape preservation
                            damping: 0.02,
                            length: this.getDistance(particle.position, farDiagonalParticle.position),
                            render: {
                                visible: false
                            }
                        });
                        constraints.push(constraint);
                    }
                });
                
                return constraints;
            }
            
            
            /**
             * Setup user interaction (mouse/touch)
             */
            setupInteraction() {
                if (!this.config.interaction.enabled) return;
                
                const mouse = Matter.Mouse.create(this.render.canvas);
                this.mouseConstraint = Matter.MouseConstraint.create(this.engine, {
                    mouse: mouse,
                    constraint: {
                        stiffness: this.config.interaction.dragStiffness,
                        render: {
                            visible: false
                        }
                    }
                });
                
                Matter.World.add(this.world, this.mouseConstraint);
                
                // Improve mouse handling for better interaction
                this.render.canvas.removeEventListener('mousewheel', mouse.mousewheel);
                this.render.canvas.removeEventListener('DOMMouseScroll', mouse.mousewheel);
            }
            
            /**
             * Setup event handlers
             */
            setupEventHandlers() {
                // Collision events
                Matter.Events.on(this.engine, 'collisionStart', (event) => {
                    this.handleCollisions(event.pairs);
                });
                
                // Mouse interaction events
                if (this.mouseConstraint) {
                    Matter.Events.on(this.mouseConstraint, 'mousedown', (event) => {
                        this.handleMouseDown(event);
                    });
                    
                    Matter.Events.on(this.mouseConstraint, 'mouseup', (event) => {
                        this.handleMouseUp(event);
                    });
                }
                
                // Before update event for performance monitoring
                Matter.Events.on(this.engine, 'beforeUpdate', (event) => {
                    this.performanceMonitor.startTiming('physics');
                });
                
                // After update event
                Matter.Events.on(this.engine, 'afterUpdate', (event) => {
                    this.performanceMonitor.endTiming('physics');
                    this.updatePerformanceMetrics();
                });
            }
            
            /**
             * Setup performance monitoring
             */
            setupPerformanceMonitoring() {
                setInterval(() => {
                    this.updatePerformanceDisplay();
                }, this.config.performance.monitorInterval);
            }
            
            /**
             * Start the simulation
             */
            start() {
                if (this.state !== 'INITIALIZED') {
                    throw new Error('Simulation must be initialized before starting');
                }
                
                Matter.Render.run(this.render);
                this.runner = Matter.Runner.create();
                Matter.Runner.run(this.runner, this.engine);
                
                this.state = 'RUNNING';
                console.log('Teddy bear simulation started');
            }
            
            /**
             * Pause the simulation
             */
            pause() {
                if (this.runner) {
                    Matter.Runner.stop(this.runner);
                    this.state = 'PAUSED';
                }
            }
            
            /**
             * Resume the simulation
             */
            resume() {
                if (this.runner && this.state === 'PAUSED') {
                    Matter.Runner.run(this.runner, this.engine);
                    this.state = 'RUNNING';
                }
            }
            
            /**
             * Reset the teddy bear to initial position
             */
            reset() {
                // Remove existing bear
                if (this.teddyBear) {
                    Matter.World.remove(this.world, this.teddyBear.particles);
                    Matter.World.remove(this.world, this.teddyBear.constraints);
                }
                
                // Recreate bear
                this.createTeddyBear();
                
                console.log('Teddy bear reset');
            }
            
            /**
             * Update configuration
             */
            updateConfig(newConfig) {
                // Update softness
                if (newConfig.bear && typeof newConfig.bear.softness === 'number') {
                    this.config.bear.softness = newConfig.bear.softness;
                    this.updateSoftness();
                }
                
                // Update gravity
                if (newConfig.physics && newConfig.physics.gravity) {
                    this.config.physics.gravity = newConfig.physics.gravity;
                    this.engine.world.gravity = newConfig.physics.gravity;
                }
            }
            
            /**
             * Update softness of all constraints
             */
            updateSoftness() {
                const stiffness = 1 - this.config.bear.softness;
                
                if (this.teddyBear && this.teddyBear.constraints) {
                    this.teddyBear.constraints.forEach(constraint => {
                        // Update stiffness based on constraint type (structural vs diagonal)
                        if (constraint.render.lineWidth >= 1) {
                            // Structural constraints
                            constraint.stiffness = stiffness * 0.8;
                        } else {
                            // Diagonal constraints
                            constraint.stiffness = stiffness * 0.4;
                        }
                    });
                }
            }
            
            /**
             * Handle collision events
             */
            handleCollisions(pairs) {
                // Update collision count for debug info
                this.lastCollisionCount = pairs.length;
            }
            
            /**
             * Handle mouse down events
             */
            handleMouseDown(event) {
                if (event.source.body) {
                    // Gentle interaction - don't overpower the bear's structure
                    event.source.constraint.stiffness = 0.3;
                }
            }
            
            /**
             * Handle mouse up events
             */
            handleMouseUp(event) {
                // Reset constraint stiffness
                if (event.source.constraint) {
                    event.source.constraint.stiffness = this.config.interaction.dragStiffness;
                }
            }
            
            /**
             * Update performance metrics
             */
            updatePerformanceMetrics() {
                const currentTime = performance.now();
                if (this.lastUpdateTime) {
                    const deltaTime = currentTime - this.lastUpdateTime;
                    this.performanceMonitor.recordMetric('frameTime', deltaTime);
                    this.performanceMonitor.recordMetric('fps', 1000 / deltaTime);
                }
                this.lastUpdateTime = currentTime;
                this.frameCount++;
            }
            
            /**
             * Update performance display
             */
            updatePerformanceDisplay() {
                const fps = Math.round(this.performanceMonitor.getAverageMetric('fps', 60) || 0);
                const physicsTime = Math.round(this.performanceMonitor.getAverageMetric('physics', 60) || 0);
                const particleCount = this.getTotalParticleCount();
                
                document.getElementById('fps').textContent = fps;
                document.getElementById('physics-time').textContent = physicsTime;
                document.getElementById('particle-count').textContent = particleCount;
                
                // Update debug info if visible
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo.style.display !== 'none') {
                    const bearPos = this.getBearPosition();
                    document.getElementById('bear-position').textContent = `${Math.round(bearPos.x)}, ${Math.round(bearPos.y)}`;
                    document.getElementById('constraint-count').textContent = this.getTotalConstraintCount();
                    
                    if (performance.memory) {
                        const memoryMB = Math.round(performance.memory.usedJSHeapSize / (1024 * 1024));
                        document.getElementById('memory-usage').textContent = memoryMB;
                    }
                    
                    document.getElementById('collision-pairs').textContent = this.lastCollisionCount || 0;
                }
            }
            
            /**
             * Get total particle count
             */
            getTotalParticleCount() {
                return this.teddyBear ? this.teddyBear.particles.length : 0;
            }
            
            /**
             * Get total constraint count
             */
            getTotalConstraintCount() {
                return this.teddyBear ? this.teddyBear.constraints.length : 0;
            }
            
            /**
             * Get bear center position
             */
            getBearPosition() {
                if (!this.teddyBear || !this.teddyBear.particles.length) return { x: 0, y: 0 };
                
                // Calculate center of mass from all particles
                let totalX = 0;
                let totalY = 0;
                this.teddyBear.particles.forEach(particle => {
                    totalX += particle.position.x;
                    totalY += particle.position.y;
                });
                
                return {
                    x: totalX / this.teddyBear.particles.length,
                    y: totalY / this.teddyBear.particles.length
                };
            }
            
            /**
             * Utility function to calculate distance between points
             */
            getDistance(pointA, pointB) {
                const dx = pointA.x - pointB.x;
                const dy = pointA.y - pointB.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            /**
             * Destroy the simulation and clean up resources
             */
            destroy() {
                if (this.runner) {
                    Matter.Runner.stop(this.runner);
                }
                
                if (this.render) {
                    Matter.Render.stop(this.render);
                }
                
                if (this.engine) {
                    Matter.Engine.clear(this.engine);
                }
                
                this.state = 'DESTROYED';
                console.log('Teddy bear simulation destroyed');
            }
        }

        // ========================================
        // Performance Monitor Class
        // ========================================
        
        class PerformanceMonitor {
            constructor() {
                this.timings = new Map();
                this.metrics = new Map();
                this.startTimes = new Map();
            }
            
            startTiming(name) {
                this.startTimes.set(name, performance.now());
            }
            
            endTiming(name) {
                const startTime = this.startTimes.get(name);
                if (startTime) {
                    const duration = performance.now() - startTime;
                    this.recordMetric(name, duration);
                    this.startTimes.delete(name);
                    return duration;
                }
                return 0;
            }
            
            recordMetric(name, value) {
                if (!this.metrics.has(name)) {
                    this.metrics.set(name, []);
                }
                
                const values = this.metrics.get(name);
                values.push(value);
                
                // Keep only last 300 values (5 seconds at 60fps)
                if (values.length > 300) {
                    values.shift();
                }
            }
            
            getAverageMetric(name, window = 60) {
                const values = this.metrics.get(name);
                if (!values || values.length === 0) return 0;
                
                const recentValues = values.slice(-window);
                const sum = recentValues.reduce((a, b) => a + b, 0);
                return sum / recentValues.length;
            }
        }

        // ========================================
        // Application Setup and Event Handlers
        // ========================================
        
        let simulation = null;
        
        /**
         * Initialize the application
         */
        async function initializeApp() {
            try {
                const canvas = document.getElementById('canvas');
                simulation = new TeddyBearSimulation(canvas);
                
                await simulation.initialize();
                simulation.start();
                
                setupUIControls();
                
                console.log('Application initialized successfully');
            } catch (error) {
                console.error('Failed to initialize application:', error);
                alert('Failed to initialize the teddy bear simulation. Please refresh the page.');
            }
        }
        
        /**
         * Setup UI controls and event handlers
         */
        function setupUIControls() {
            // Reset button
            document.getElementById('reset-btn').addEventListener('click', () => {
                simulation.reset();
            });
            
            // Pause/Resume button
            const pauseBtn = document.getElementById('pause-btn');
            pauseBtn.addEventListener('click', () => {
                if (simulation.state === 'RUNNING') {
                    simulation.pause();
                    pauseBtn.textContent = 'Resume';
                } else if (simulation.state === 'PAUSED') {
                    simulation.resume();
                    pauseBtn.textContent = 'Pause';
                }
            });
            
            // Softness slider
            const softnessSlider = document.getElementById('softness-slider');
            const softnessValue = document.getElementById('softness-value');
            
            softnessSlider.addEventListener('input', (e) => {
                const softness = e.target.value / 100;
                softnessValue.textContent = softness.toFixed(1);
                simulation.updateConfig({
                    bear: { softness: softness }
                });
            });
            
            // Gravity slider
            const gravitySlider = document.getElementById('gravity-slider');
            const gravityValue = document.getElementById('gravity-value');
            
            gravitySlider.addEventListener('input', (e) => {
                const gravity = e.target.value / 100;
                gravityValue.textContent = gravity.toFixed(1);
                simulation.updateConfig({
                    physics: {
                        gravity: { x: 0, y: gravity, scale: 0.001 }
                    }
                });
            });
            
            // Debug mode toggle
            const debugBtn = document.getElementById('debug-btn');
            const debugInfo = document.getElementById('debug-info');
            
            debugBtn.addEventListener('click', () => {
                if (debugInfo.style.display === 'none') {
                    debugInfo.style.display = 'block';
                    debugBtn.textContent = 'Hide Debug';
                } else {
                    debugInfo.style.display = 'none';
                    debugBtn.textContent = 'Debug Mode';
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'r':
                    case 'R':
                        simulation.reset();
                        break;
                    case ' ':
                        e.preventDefault();
                        pauseBtn.click();
                        break;
                    case 'd':
                    case 'D':
                        debugBtn.click();
                        break;
                }
            });
        }
        
        /**
         * Handle window resize
         */
        window.addEventListener('resize', () => {
            // Note: For a production version, you might want to implement
            // canvas resizing and viewport adjustment here
        });
        
        /**
         * Handle page unload
         */
        window.addEventListener('beforeunload', () => {
            if (simulation) {
                simulation.destroy();
            }
        });
        
        // ========================================
        // Application Start
        // ========================================
        
        // Start the application when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Expose simulation for debugging (development only)
        if (typeof window !== 'undefined') {
            window.teddyBearSimulation = simulation;
        }
    </script>
</body>
</html>